# SPDX-License-Identifier: Apache-2.0
name: Solo E2E Test

on:
  # Reusable workflow trigger - called by solo-e2e-scheduler.yml
  workflow_call:
    inputs:
      topology:
        description: "Network topology"
        type: string
        default: "single"
      block-node-version:
        description: "Block Node version ('latest', 'rc', 'main', or tag like 'v0.21.2')"
        type: string
        default: "latest"
      consensus-node-version:
        description: "Consensus Node version ('latest', 'rc', 'main', or tag like 'v0.68.6')"
        type: string
        default: "latest"
      mirror-node-version:
        description: "Mirror Node version ('latest', 'rc', 'main', or tag like 'v0.146.0')"
        type: string
        default: "latest"
      solo-version:
        description: "Solo CLI Version"
        type: string
        default: "0.54.0"
      run-tck-regression-tests:
        description: "Run TCK regression test"
        type: boolean
        default: false
      nlg-test-class:
        description: "NLG test class"
        type: string
        default: "CryptoTransferLoadTest"
      nlg-concurrency:
        description: "NLG -c (concurrency threads)"
        type: string
        default: "5"
      nlg-accounts:
        description: "NLG -a (number of accounts)"
        type: string
        default: "10"
      nlg-duration:
        description: "NLG -t (seconds, 0 to skip load gen)"
        type: string
        default: "300"
      nlg-extra-args:
        description: "NLG extra args (e.g., '-T 5 -K ED25519')"
        type: string
        default: ""
      nlg-max-tps:
        description: "NLG --max-tps (max transactions per second, optional)"
        type: string
        default: ""
      mirror-node-pinger-tps:
        description: "Mirror Node pinger TPS (0 to disable)"
        type: string
        default: "5"
      test-definition:
        description: "Test definitions to run (comma-separated, e.g., 'smoke-test,basic-load')"
        type: string
        default: "none"
    outputs:
      result:
        description: "Test result (success or failure)"
        value: ${{ jobs.solo-test-deploy.outputs.result }}
      resolved-versions:
        description: "Resolved versions (CN,MN,BN)"
        value: ${{ jobs.solo-test-deploy.outputs.resolved-versions }}

  # Manual trigger - for direct invocation from GitHub UI
  workflow_dispatch:
    inputs:
      topology:
        description: "Network topology"
        required: false
        default: "single"
        type: choice
        options:
          - single # 1 CN, 1 BN
          - paired-3 # 3 CN, 3 BN
          - fan-out-3cn-2bn # 3 CN, 2 BN
          - 3cn-1bn # 3 CN, 1 BN
          - 7cn-3bn-distributed # 7 CN, 3 BN distributed
          - minimal # like single but without MN, Relay and Explorer
      block-node-version:
        description: "Block Node version ('latest', 'rc', 'main', or tag like 'v0.21.2')"
        required: false
        default: "latest"
      consensus-node-version:
        description: "Consensus Node version ('latest', 'rc', 'main', or tag like 'v0.68.6')"
        required: false
        default: "latest"
      mirror-node-version:
        description: "Mirror Node version ('latest', 'rc', 'main', or tag like 'v0.146.0')"
        required: false
        default: "latest"
      solo-version:
        description: "Solo CLI Version"
        required: false
        default: "0.54.0"
      run-tck-regression-tests:
        description: "Run TCK regression test"
        required: false
        default: false
        type: boolean
      nlg-test-class:
        description: "NLG test class"
        required: false
        default: "CryptoTransferLoadTest"
        type: choice
        options:
          - CryptoTransferLoadTest
          - HCSLoadTest
          - TokenTransferLoadTest
      nlg-concurrency:
        description: "NLG -c (concurrency threads)"
        required: false
        default: "5"
      nlg-accounts:
        description: "NLG -a (number of accounts)"
        required: false
        default: "10"
      nlg-duration:
        description: "NLG -t (seconds, 0 to skip load gen)"
        required: false
        default: "300"
      nlg-extra-args:
        description: "NLG extra args (e.g., '-T 5 -K ED25519')"
        required: false
        default: ""
      nlg-max-tps:
        description: "NLG --max-tps (max transactions per second, optional)"
        required: false
        default: ""
      mirror-node-pinger-tps:
        description: "Mirror Node pinger TPS (0 to disable)"
        required: false
        default: "5"
      test-definition:
        description: "Test definitions (comma-separated: smoke-test,basic-load,node-restart-resilience)"
        required: false
        default: "none"

defaults:
  run:
    shell: bash

permissions:
  contents: read
  id-token: write

concurrency:
  group: solo-network
  cancel-in-progress: true

env:
  GRADLE_EXEC: "ionice -c 2 -n 2 nice -n 19 ./gradlew "
  # Solo ENV
  DEPLOYMENT: "deployment-solo"
  NAMESPACE: "solo-network"
  CLUSTER_NAME: "solo-cluster"
  CONTEXT: "kind-solo-cluster"
  CLUSTER_REFERENCE: "kind-solo-cluster"
  # Solo CLI environment variables
  MIRROR_NODE_PINGER_TPS: ${{ inputs.mirror-node-pinger-tps }}

jobs:
  solo-test-deploy:
    runs-on: hiero-block-node-linux-medium
    outputs:
      result: ${{ steps.result.outputs.status }}
      resolved-versions: ${{ steps.versions.outputs.cn_version }},${{ steps.versions.outputs.mn_version }},${{ steps.versions.outputs.bn_version }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: "22"

      - name: Install Helm
        uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4.3.1

      - name: Setup Kind
        uses: helm/kind-action@92086f6be054225fa813e0a4b13787fc9088faab # v1.13.0
        with:
          install_only: true
          node_image: kindest/node:v1.31.4@sha256:2cb39f7295fe7eafee0842b1052a599a4fb0f8bcf3f83d96c7f4864c357c6c30
          version: v0.26.0
          kubectl_version: v1.31.4
          verbosity: 3
          wait: 120s

      - name: Install JDK
        uses: actions/setup-java@be666c2fcd27ec809703dec50e508c2fdc7f6654 # v5.2.0
        with:
          distribution: "temurin"
          java-version: "25.0.2"

      # Resolve 'latest' versions to actual GA releases
      - name: Resolve component versions
        id: versions
        run: |
          OUTPUT=$(./tools-and-tests/scripts/solo-e2e-test/scripts/resolve-versions.sh \
            "${{ inputs.consensus-node-version }}" \
            "${{ inputs.mirror-node-version }}" \
            "${{ inputs.block-node-version }}")
          echo "$OUTPUT"
          # Parse output and write to GITHUB_OUTPUT
          echo "$OUTPUT" | grep "^cn_version=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^mn_version=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^bn_version=" >> "${GITHUB_OUTPUT}"

      # Install Solo CLI
      - name: Install Solo CLI via npm
        id: solo
        run: |
          npm i @hashgraph/solo@${{ inputs.solo-version }} -g
          # Extract version number from solo output (handles various output formats)
          SOLO_INSTALLED=$(solo --version 2>/dev/null | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "unknown")
          echo "Solo version: ${SOLO_INSTALLED}"
          echo "solo_version=${SOLO_INSTALLED}" >> "${GITHUB_OUTPUT}"

        # Produce protobuf source artifact
      - name: Produce Protobuf proto artifact
        run: ${GRADLE_EXEC} :protobuf-sources:generateBlockNodeProtoArtifact

        # Untar protobuf sources
      - name: Untar Protobuf Sources
        working-directory: protobuf-sources
        run: |
          mkdir -p proto
          # Use the generated protobuf artifact (matches local project version)
          PROTO_FILE=$(ls block-node-protobuf-*.tgz 2>/dev/null | head -1)
          if [[ -z "$PROTO_FILE" ]]; then
            echo "Error: No protobuf artifact found"
            ls -la
            exit 1
          fi
          echo "Using protobuf artifact: $PROTO_FILE"
          tar -xzf "$PROTO_FILE" -C proto

      - name: Install grpcurl
        run: |
          curl -L https://github.com/fullstorydev/grpcurl/releases/download/v1.8.7/grpcurl_1.8.7_linux_x86_64.tar.gz -o grpcurl.tar.gz
          sudo tar -xzf grpcurl.tar.gz -C /usr/local/bin grpcurl
          rm grpcurl.tar.gz

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # Setup cluster using shared script
      - name: Cluster setup (Kind + Solo)
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-setup-cluster.sh \
            --cluster-name "${CLUSTER_NAME}" \
            --namespace "${NAMESPACE}" \
            --deployment "${DEPLOYMENT}" \
            --topology "${{ inputs.topology }}" \
            --topologies-dir "${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies"

          TOPOLOGY_FILE="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies/${{ inputs.topology }}.yaml"

          # Add to step summary
          {
            echo "### Cluster Configuration"
            echo ""
            echo "| Setting | Value |"
            echo "|---------|-------|"
            echo "| Topology | ${{ inputs.topology }} |"
            echo "| Cluster Name | ${CLUSTER_NAME} |"
            echo "| Namespace | ${NAMESPACE} |"
            echo ""
            echo "<details>"
            echo "<summary>Topology Definition (${{ inputs.topology }}.yaml)</summary>"
            echo ""
            echo '```yaml'
            cat "$TOPOLOGY_FILE"
            echo '```'
            echo ""
            echo "</details>"
            echo ""
          } >> "${GITHUB_STEP_SUMMARY}"

      # Deploy network using shared script
      - name: Deploy network
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-deploy-network.sh \
            --deployment "${DEPLOYMENT}" \
            --namespace "${NAMESPACE}" \
            --cluster-ref "${CLUSTER_REFERENCE}" \
            --topology "${{ inputs.topology }}" \
            --topologies-dir "${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies" \
            --cn-version "${{ steps.versions.outputs.cn_version }}" \
            --mn-version "${{ steps.versions.outputs.mn_version }}" \
            --bn-version "${{ steps.versions.outputs.bn_version }}"

          # Add to step summary - comprehensive version summary
          {
            echo "### Component Versions"
            echo ""
            echo "| Component | Requested | Resolved |"
            echo "|-----------|-----------|----------|"
            echo "| Consensus Node | \`${{ inputs.consensus-node-version || 'latest' }}\` | \`${{ steps.versions.outputs.cn_version }}\` |"
            echo "| Mirror Node | \`${{ inputs.mirror-node-version || 'latest' }}\` | \`${{ steps.versions.outputs.mn_version }}\` |"
            echo "| Block Node | \`${{ inputs.block-node-version || 'latest' }}\` | \`${{ steps.versions.outputs.bn_version }}\` |"
            echo "| Solo CLI | \`${{ inputs.solo-version || 'latest' }}\` | \`${{ steps.solo.outputs.solo_version }}\` |"
            echo ""
          } >> "${GITHUB_STEP_SUMMARY}"

      - name: Show running pods and services
        run: |
          kubectl --context "${CONTEXT}" get pods -n ${NAMESPACE}
          kubectl --context "${CONTEXT}" get svc -n ${NAMESPACE}

      # Port forwards - dynamically discover and forward all nodes
      - name: Solo Port forwards
        run: |
          ${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/scripts/solo-port-forward.sh \
            --namespace "${NAMESPACE}"

      # ---- Load Generation with NLG (Optional) skip if duration = 0 ----

      # Start load generation
      - name: Start NLG Load Generation
        if: ${{ inputs.nlg-duration != '0' }}
        continue-on-error: true
        env:
          NLG_TEST_CLASS: ${{ inputs.nlg-test-class }}
          NLG_CONCURRENCY: ${{ inputs.nlg-concurrency }}
          NLG_ACCOUNTS: ${{ inputs.nlg-accounts }}
          NLG_DURATION: ${{ inputs.nlg-duration }}
          NLG_EXTRA_ARGS: ${{ inputs.nlg-extra-args }}
          NLG_MAX_TPS: ${{ inputs.nlg-max-tps }}
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-load-generate.sh start

          # Add to step summary
          {
            echo "### Load Generation"
            echo ""
            echo "| Setting | Value |"
            echo "|---------|-------|"
            echo "| Test Class | \`${{ inputs.nlg-test-class }}\` |"
            echo "| Concurrency | ${{ inputs.nlg-concurrency }} |"
            echo "| Accounts | ${{ inputs.nlg-accounts }} |"
            echo "| Duration | ${{ inputs.nlg-duration }}s |"
            echo "| Extra Args | \`${{ inputs.nlg-extra-args }}\` |"
            echo "| Max TPS | ${{ inputs.nlg-max-tps || 'unlimited' }} |"
            echo ""
          } >> "${GITHUB_STEP_SUMMARY}"

      # ---- Test Definition Runner (optional) ----
      # Run a test definition file if specified. This provides a structured
      # way to define timed events and assertions for E2E testing.

      # Validate all test definitions against topology before running
      - name: Validate Test Definitions
        if: ${{ inputs.test-definition != 'none' && inputs.test-definition != '' }}
        run: |
          TESTS_DIR="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/tests"
          TOPOLOGIES_DIR="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies"
          TEST_RUNNER="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/scripts/solo-test-runner.sh"

          IFS=',' read -ra TESTS <<< "${{ inputs.test-definition }}"
          echo "Validating ${#TESTS[@]} test(s) against topology '${{ inputs.topology }}'..."

          for test in "${TESTS[@]}"; do
            test=$(echo "$test" | xargs)  # trim whitespace
            [[ -z "$test" || "$test" == "none" ]] && continue
            echo "Validating: $test"
            if ! "${TEST_RUNNER}" --test "${TESTS_DIR}/${test}.yaml" --topology "${{ inputs.topology }}" --topologies-dir "${TOPOLOGIES_DIR}" --validate; then
              echo "::error::Test '$test' is not compatible with topology '${{ inputs.topology }}'"
              exit 1
            fi
          done
          echo "All tests validated successfully"

      # Run each test definition sequentially on the same deployment
      - name: Run Test Definitions
        if: ${{ inputs.test-definition != 'none' && inputs.test-definition != '' }}
        run: |
          TESTS_DIR="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/tests"
          TOPOLOGIES_DIR="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies"
          TEST_RUNNER="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/scripts/solo-test-runner.sh"

          IFS=',' read -ra TESTS <<< "${{ inputs.test-definition }}"
          FAILED=0

          for test in "${TESTS[@]}"; do
            test=$(echo "$test" | xargs)  # trim whitespace
            [[ -z "$test" || "$test" == "none" ]] && continue

            echo ""
            echo "=========================================="
            echo "Running test: $test"
            echo "=========================================="

            if ! "${TEST_RUNNER}" \
              --test "${TESTS_DIR}/${test}.yaml" \
              --topology "${{ inputs.topology }}" \
              --namespace "${NAMESPACE}" \
              --context "${CONTEXT}" \
              --topologies-dir "${TOPOLOGIES_DIR}" \
              --proto-path "protobuf-sources/proto" \
              --output github-summary; then
              echo "::warning::Test '$test' failed"
              FAILED=$((FAILED + 1))
            fi
          done

          if [[ $FAILED -gt 0 ]]; then
            echo "::error::$FAILED test(s) failed"
            exit 1
          fi

      # ---- BN verification with grpcurl ----
      # Verify the BN is getting blocks
      - name: Get ServerStatus from Block Node
        run: |
          # Call serverStatus once
          STATUS_JSON=$(grpcurl \
            -plaintext \
            -emit-defaults \
            -import-path protobuf-sources/proto \
            -proto block-node/api/node_service.proto \
            -d '{}' \
            localhost:40840 \
            org.hiero.block.api.BlockNodeService/serverStatus)

          # Extract values
          FIRST_AVAILABLE_BLOCK=$(echo "$STATUS_JSON" | jq -r '.firstAvailableBlock')
          LAST_AVAILABLE_BLOCK=$(echo "$STATUS_JSON" | jq -r '.lastAvailableBlock')

          echo "First available block is $FIRST_AVAILABLE_BLOCK"
          echo "Last available block is $LAST_AVAILABLE_BLOCK"

          # Validate
          if [[ "$FIRST_AVAILABLE_BLOCK" != "0" ]]; then
              echo "First available block is not 0"
              exit 1
          fi
          if (( LAST_AVAILABLE_BLOCK < 1 )); then
              echo "Last available block is less than 1"
              exit 1
          fi

          # Export for later steps
          echo "FIRST_AVAILABLE_BLOCK=$FIRST_AVAILABLE_BLOCK" >> $GITHUB_ENV
          echo "LAST_AVAILABLE_BLOCK=$LAST_AVAILABLE_BLOCK" >> $GITHUB_ENV

      - name: Get first block from Block Node
        run: |
          FIRST_BLOCK=$(grpcurl \
            -plaintext \
            -emit-defaults \
            -max-msg-sz 268435456 \
            -import-path protobuf-sources/proto \
            -proto block-node/api/block_access_service.proto \
            -d "{\"block_number\": $FIRST_AVAILABLE_BLOCK}" \
            localhost:40840 \
            org.hiero.block.api.BlockAccessService/getBlock \
            | jq -r '.block.items[0].blockHeader.number')
          if [ -z "FIRST_BLOCK" ]; then
            echo "Error: FIRST_BLOCK is empty"
            exit 1
          fi
          echo "FirstBlock is ${FIRST_BLOCK}"

      - name: Get last block from Block Node
        run: |
          LAST_BLOCK=$(grpcurl \
            -plaintext \
            -emit-defaults \
            -max-msg-sz 268435456 \
            -import-path protobuf-sources/proto \
            -proto block-node/api/block_access_service.proto \
            -d "{\"block_number\": $LAST_AVAILABLE_BLOCK}" \
            localhost:40840 \
            org.hiero.block.api.BlockAccessService/getBlock \
            | jq -r '.block.items[0].blockHeader.number')
          if [ -z "LAST_BLOCK" ]; then
            echo "Error: LAST_BLOCK is empty"
            exit 1
          fi
          echo "LastBlock is ${LAST_BLOCK}"

      - name: Validate first block on Mirror Node
        run: |
          # Fetch the block number from Mirror Node
          FIRST_BLOCK_MIRROR=$(curl -s "http://127.0.0.1:5551/api/v1/blocks/$FIRST_AVAILABLE_BLOCK" | jq -r '.number')

          # Check if we got a value
          if [ -z "$FIRST_BLOCK_MIRROR" ]; then
            echo "Error: FIRST_BLOCK_MIRROR is empty"
            exit 1
          fi

          echo "FIRST_BLOCK_MIRROR is $FIRST_BLOCK_MIRROR"
          echo "FIRST_AVAILABLE_BLOCK is $FIRST_AVAILABLE_BLOCK"

          # Validate that the Mirror Node block matches the Block Node first block
          if [ "$FIRST_BLOCK_MIRROR" != "$FIRST_AVAILABLE_BLOCK" ]; then
            echo "Error: Mirror Node first block ($FIRST_BLOCK_MIRROR) does not match Block Node first block ($FIRST_AVAILABLE_BLOCK)"
            exit 1
          fi

          echo "Mirror Node first block matches Block Node first block"

      - name: Validate last block on Mirror Node
        run: |
          # Fetch the block number from Mirror Node
          LAST_BLOCK_MIRROR=$(curl -s "http://127.0.0.1:5551/api/v1/blocks/$LAST_AVAILABLE_BLOCK" | jq -r '.number')

          # Check if we got a value
          if [ -z "$LAST_BLOCK_MIRROR" ]; then
              echo "Error: LAST_BLOCK_MIRROR is empty"
              exit 1
          fi

          echo "LAST_BLOCK_MIRROR is $LAST_BLOCK_MIRROR"
          echo "LAST_AVAILABLE_BLOCK is $LAST_AVAILABLE_BLOCK"

          # Validate that the Mirror Node block matches the Block Node last block
          if [ "$LAST_BLOCK_MIRROR" != "$LAST_AVAILABLE_BLOCK" ]; then
              echo "Error: Mirror Node last block ($LAST_BLOCK_MIRROR) does not match Block Node last block ($LAST_AVAILABLE_BLOCK)"
              exit 1
          fi

          echo "Mirror Node last block matches Block Node last block"

      # Network Health Summary - show status of all nodes
      - name: Network Health Summary
        if: always()
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-network-status.sh \
            --namespace "${NAMESPACE}" \
            --topology "${{ inputs.topology }}" \
            --topologies-dir "${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies" \
            --context "${CONTEXT}" \
            --proto-path "protobuf-sources/proto" \
            --output github-summary

      # Block Node Metrics Summary - show metrics for each block node
      - name: Block Node Metrics Summary
        if: always()
        run: |
          TOPOLOGY_FILE="${{ github.workspace }}/tools-and-tests/scripts/solo-e2e-test/topologies/${{ inputs.topology }}.yaml"
          BLOCK_NODES=$(grep -E '^[[:space:]]+block-node-[0-9]+:' "${TOPOLOGY_FILE}" | sed 's/://g' | awk '{print $1}' || echo "block-node-1")

          PORT=16007
          for bn in ${BLOCK_NODES}; do
            echo "<details>" >> "${GITHUB_STEP_SUMMARY}"
            echo "<summary>ðŸ“Š ${bn} Metrics</summary>" >> "${GITHUB_STEP_SUMMARY}"
            echo "" >> "${GITHUB_STEP_SUMMARY}"
            ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-metrics-summary.sh \
              ${PORT} github-summary >> "${GITHUB_STEP_SUMMARY}" || echo "Metrics unavailable for ${bn}" >> "${GITHUB_STEP_SUMMARY}"
            echo "</details>" >> "${GITHUB_STEP_SUMMARY}"
            echo "" >> "${GITHUB_STEP_SUMMARY}"
            PORT=$((PORT + 1))
          done

      # TCK Regression Tests related steps (matches consensus-node approach)
      - name: Setup PNPM
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          npm install -g pnpm

      # Checkout TCK and checkout latest tag
      - name: Checkout TCK SDK
        if: ${{ inputs.run-tck-regression-tests }}
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          path: sdk-tck/regression
          repository: hiero-ledger/hiero-sdk-tck
          fetch-depth: 0
          fetch-tags: true

      - name: Checkout Latest Tag (TCK)
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          cd sdk-tck/regression
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0)
          echo "Checking out TCK latest tag: $LATEST_TAG"
          git checkout "$LATEST_TAG"

      # Checkout JS-SDK and checkout latest tag
      - name: Checkout JS-SDK Server
        if: ${{ inputs.run-tck-regression-tests }}
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          path: sdk-tck/sdk-server
          repository: hiero-ledger/hiero-sdk-js
          fetch-depth: 0
          fetch-tags: true

      - name: Checkout Latest Tag (JS-SDK)
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          cd sdk-tck/sdk-server
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0)
          echo "Checking out JS-SDK latest tag: $LATEST_TAG"
          git checkout "$LATEST_TAG"

      # Install TCK-SDK dependencies using shared script (versions extracted from source)
      - name: Install TCK-SDK Dependencies
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-tck-sdk-install.sh \
            --sdk-dir "sdk-tck/sdk-server" \
            --tck-dir "sdk-tck/regression"

      # Run TCK-SDK tests using shared script
      - name: Run TCK-SDK Tests
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-tck-sdk-run.sh \
            --sdk-dir "sdk-tck/sdk-server" \
            --tck-dir "sdk-tck/regression" \
            --deployment "${DEPLOYMENT}" \
            --namespace "${NAMESPACE}"

      - name: BN Based - SDK TCK Regression Test Report
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: ${{ !cancelled()  &&  inputs.run-tck-regression-tests }}
        with:
          name: SDK TCK Regression Test Report
          path: "**/sdk-tck/regression/mochawesome-report/mochawesome.*"
          retention-days: 7

      # Stop load generator if it was started
      - name: Stop NLG Load Generation
        if: ${{ always() && inputs.nlg-duration != '0' }}
        continue-on-error: true
        env:
          NLG_TEST_CLASS: ${{ inputs.nlg-test-class }}
        run: |
          ./tools-and-tests/scripts/solo-e2e-test/scripts/solo-load-generate.sh stop || true

      - name: Collect BN and MN Logs
        if: always()
        run: |
          # Create log directories
          mkdir -p bn-logs mn-logs

          # Get BN Logs for ALL block nodes dynamically
          for svc in $(kubectl --context "${CONTEXT}" get svc -n "${NAMESPACE}" -o name 2>/dev/null | grep "block-node-" | sort); do
            bn_name=$(basename "$svc")
            kubectl --context "${CONTEXT}" logs -n "${NAMESPACE}" -l "app.kubernetes.io/name=${bn_name}" \
              --all-containers --since=24h --timestamps --prefix --tail=-1 > "bn-logs/${bn_name}.log" 2>&1 || \
              echo "Failed to collect logs for ${bn_name} (cluster may be unavailable)" > "bn-logs/${bn_name}.log"
            echo "Collected logs for ${bn_name}"
          done

          # Get MN Logs
          kubectl --context "${CONTEXT}" logs -n "${NAMESPACE}" -l "app.kubernetes.io/instance=mirror-1,app.kubernetes.io/component=importer" \
            --all-containers --since=24h --timestamps --prefix --tail=-1 > "mn-logs/mirror-1-importer.log" 2>&1 || \
            echo "Failed to collect MN logs (cluster may be unavailable)" > "mn-logs/mirror-1-importer.log"

          # Show what was collected
          echo "=== Collected BN logs ===" && ls -la bn-logs/
          echo "=== Collected MN logs ===" && ls -la mn-logs/

      - name: Collect CN Logs
        if: always()
        run: |
          # Get CN Logs (Solo 0.52+ uses 'deployment diagnostics' instead of 'consensus diagnostics')
          solo deployment diagnostics all --dev --deployment "${DEPLOYMENT}" || \
            echo "Failed to collect CN diagnostics (deployment may be unavailable)"
          LOG_FOLDER="${HOME}/.solo/logs"
          echo "CN_LOG_FOLDER=$LOG_FOLDER" >> $GITHUB_ENV
          ls -lR "$LOG_FOLDER"

      - name: List CN logs
        if: always()
        run: ls -lR "${{ env.CN_LOG_FOLDER }}"

      - name: Upload CN Logs
        if: always()
        id: upload_logs_cn
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: cn-logs
          path: ${{ env.CN_LOG_FOLDER }}/*.zip

      - name: Upload BN Logs
        if: always()
        id: upload_logs_bn
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: BN-logs
          path: bn-logs/

      - name: Upload MN Logs
        if: always()
        id: upload_logs_mn
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: MN-logs
          path: mn-logs/

      - name: Add Logs to Summary
        if: always()
        run: |
          {
            echo "### Logs"
            echo ""
            echo "You can download the logs from this run here:"
            echo "- [Download BN-logs](${{ steps.upload_logs_bn.outputs.artifact-url }})"
            echo "- [Download MN-logs](${{ steps.upload_logs_mn.outputs.artifact-url }})"
            echo "- [Download CN-logs](${{ steps.upload_logs_cn.outputs.artifact-url }})"

          } >> "$GITHUB_STEP_SUMMARY"

      # Set result output for workflow_call consumers
      - name: Set result output
        id: result
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "status=success" >> "$GITHUB_OUTPUT"
          else
            echo "status=failure" >> "$GITHUB_OUTPUT"
          fi

      # Stop the solo nodes
      - name: Stop solo
        if: ${{ always() }}
        run: |
          kind delete cluster -n ${{ env.CLUSTER_NAME }}
