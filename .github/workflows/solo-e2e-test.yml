# SPDX-License-Identifier: Apache-2.0
name: Solo E2E Test

on:
  workflow_dispatch:
    inputs:
      topology:
        description: "Network topology"
        required: false
        default: "single"
        type: choice
        options:
          - single # 1 CN, 1 BN
          - paired-3 # 3 CN, 3 BN
          - fan-out-3cn-2bn # 3 CN, 2 BN
      block-node-version:
        description: "Block Node version ('latest' for GA, 'main' for snapshot, or specific tag like 'v0.21.2')"
        required: false
        default: "latest"
      consensus-node-version:
        description: "Consensus Node version ('latest' for GA or specific tag like 'v0.68.6')"
        required: false
        default: "latest"
      mirror-node-version:
        description: "Mirror Node version ('latest' for GA or specific tag like 'v0.146.0')"
        required: false
        default: "latest"
      solo-version:
        description: "Solo CLI Version"
        required: false
        default: "latest"
      run-tck-regression-tests:
        description: "Run TCK regression test"
        required: false
        default: false
        type: boolean
      load-tps:
        description: "Target TPS for load generation (1-20000, 0 to disable load gen and use pinger only)"
        required: false
        default: "100"
      load-duration:
        description: "Duration for load generation (e.g., '5m' for 5 minutes, '1h' for 1 hour)"
        required: false
        default: "5m"
      load-test-class:
        description: "NLG test class to run"
        required: false
        default: "CryptoTransferLoadTest"
        type: choice
        options:
          - CryptoTransferLoadTest
          - HCSLoadTest
          - TokenTransferLoadTest

defaults:
  run:
    shell: bash

permissions:
  contents: read
  id-token: write

concurrency:
  group: solo-network
  cancel-in-progress: true

env:
  GRADLE_EXEC: "ionice -c 2 -n 2 nice -n 19 ./gradlew "
  # Solo ENV
  DEPLOYMENT: "deployment-network-with-block-node"
  NAMESPACE: "namespace-network-with-block-node"
  CLUSTER_NAME: "solo-cluster"
  CONTEXT: "kind-solo-cluster"
  CLUSTER_REFERENCE: "kind-solo-cluster"

jobs:
  solo-test-deploy:
    runs-on: hiero-block-node-linux-medium
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: "20.19.4"

      - name: Install Helm
        uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4.3.1

      - name: Setup Kind
        uses: helm/kind-action@92086f6be054225fa813e0a4b13787fc9088faab # v1.13.0
        with:
          install_only: true
          node_image: kindest/node:v1.31.4@sha256:2cb39f7295fe7eafee0842b1052a599a4fb0f8bcf3f83d96c7f4864c357c6c30
          version: v0.26.0
          kubectl_version: v1.31.4
          verbosity: 3
          wait: 120s

      - name: Install JDK
        uses: actions/setup-java@be666c2fcd27ec809703dec50e508c2fdc7f6654 # v5.2.0
        with:
          distribution: "temurin"
          java-version: "25.0.2"

      # Resolve 'latest' versions to actual GA releases
      - name: Resolve component versions
        id: versions
        run: |
          OUTPUT=$(./.github/workflows/support/scripts/resolve-versions.sh \
            "${{ inputs.consensus-node-version }}" \
            "${{ inputs.mirror-node-version }}" \
            "${{ inputs.block-node-version }}")
          echo "$OUTPUT"
          # Parse output and write to GITHUB_OUTPUT
          echo "$OUTPUT" | grep "^cn_version=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^mn_version=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^bn_version=" >> "${GITHUB_OUTPUT}"

      # Install Solo CLI
      - name: Install Solo CLI via npm
        id: solo
        run: |
          npm i @hashgraph/solo@${{ inputs.solo-version }} -g
          SOLO_INSTALLED=$(solo --version)
          echo "Solo version: ${SOLO_INSTALLED}"
          echo "solo_version=${SOLO_INSTALLED}" >> "${GITHUB_OUTPUT}"

      # Setup cluster using shared script
      - name: Cluster setup (Kind + Solo)
        id: cluster
        run: |
          OUTPUT=$(./.github/workflows/support/scripts/solo-setup-cluster.sh \
            --cluster-name "${CLUSTER_NAME}" \
            --namespace "${NAMESPACE}" \
            --deployment "${DEPLOYMENT}" \
            --topology "${{ inputs.topology }}" \
            --topologies-dir "${{ github.workspace }}/tools-and-tests/scripts/network-topology-tool/topologies")
          echo "$OUTPUT"
          # Parse output and write to GITHUB_OUTPUT
          echo "$OUTPUT" | grep "^node_count=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^node_aliases=" >> "${GITHUB_OUTPUT}"

          # Add to step summary
          {
            echo "### Cluster Configuration"
            echo ""
            echo "| Setting | Value |"
            echo "|---------|-------|"
            echo "| Topology | ${{ inputs.topology }} |"
            echo "| Cluster Name | ${CLUSTER_NAME} |"
            echo "| Namespace | ${NAMESPACE} |"
            echo ""
          } >> "${GITHUB_STEP_SUMMARY}"

      # Deploy network using shared script
      - name: Deploy network
        id: network
        run: |
          OUTPUT=$(./.github/workflows/support/scripts/solo-deploy-network.sh \
            --deployment "${DEPLOYMENT}" \
            --namespace "${NAMESPACE}" \
            --cluster-ref "${CLUSTER_REFERENCE}" \
            --topology "${{ inputs.topology }}" \
            --topologies-dir "${{ github.workspace }}/tools-and-tests/scripts/network-topology-tool/topologies" \
            --cn-version "${{ steps.versions.outputs.cn_version }}" \
            --mn-version "${{ steps.versions.outputs.mn_version }}" \
            --bn-version "${{ steps.versions.outputs.bn_version }}")
          echo "$OUTPUT"
          # Parse output and write to GITHUB_OUTPUT
          echo "$OUTPUT" | grep "^cn_count=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^bn_count=" >> "${GITHUB_OUTPUT}"
          echo "$OUTPUT" | grep "^node_aliases=" >> "${GITHUB_OUTPUT}"

          # Add to step summary - comprehensive version summary
          {
            echo "### Component Versions"
            echo ""
            echo "| Component | Requested | Resolved |"
            echo "|-----------|-----------|----------|"
            echo "| Consensus Node | \`${{ inputs.consensus-node-version || 'latest' }}\` | \`${{ steps.versions.outputs.cn_version }}\` |"
            echo "| Mirror Node | \`${{ inputs.mirror-node-version || 'latest' }}\` | \`${{ steps.versions.outputs.mn_version }}\` |"
            echo "| Block Node | \`${{ inputs.block-node-version || 'latest' }}\` | \`${{ steps.versions.outputs.bn_version }}\` |"
            echo "| Solo CLI | \`${{ inputs.solo-version || 'latest' }}\` | \`${{ steps.solo.outputs.solo_version }}\` |"
            echo ""
          } >> "${GITHUB_STEP_SUMMARY}"

      - name: Show running pods and services
        run: |
          kubectl get pods -n ${NAMESPACE}
          kubectl get svc -n ${NAMESPACE}

      # Port forwards - dynamically discover and forward all nodes
      - name: Solo Port forwards
        run: |
          ${{ github.workspace }}/.github/workflows/support/scripts/solo-port-forward.sh \
            --namespace "${NAMESPACE}"

      # ---- Load Generation with NLG ----

      # Start load generation if TPS > 0
      - name: Start NLG Load Generation
        if: ${{ inputs.load-tps != '0' }}
        run: |
          OUTPUT=$(./.github/workflows/support/scripts/solo-load-generate.sh \
            --deployment "${DEPLOYMENT}" \
            --action start \
            --tps "${{ inputs.load-tps }}" \
            --duration "${{ inputs.load-duration }}" \
            --test-class "${{ inputs.load-test-class }}")
          echo "$OUTPUT"

          # Parse output for step summary
          ACCOUNTS=$(echo "$OUTPUT" | grep "^accounts=" | cut -d= -f2)
          CONCURRENCY=$(echo "$OUTPUT" | grep "^concurrency=" | cut -d= -f2)

          # Add to step summary
          {
            echo "### Load Generation"
            echo ""
            echo "| Setting | Value |"
            echo "|---------|-------|"
            echo "| Test Class | \`${{ inputs.load-test-class }}\` |"
            echo "| Target TPS | ${{ inputs.load-tps }} |"
            echo "| Duration | ${{ inputs.load-duration }} |"
            echo "| Accounts | ${ACCOUNTS} |"
            echo "| Concurrency | ${CONCURRENCY} |"
            echo ""
          } >> "${GITHUB_STEP_SUMMARY}"

      - name: Skip load generation (using pinger only)
        if: ${{ inputs.load-tps == '0' }}
        run: |
          echo "Load generation disabled (TPS=0), relying on Mirror Node pinger for minimal transaction generation"

      # ---- BN verification with grpcurl ----

      # Produce protobuf source artifact
      - name: Produce Protobuf proto artifact
        run: ${GRADLE_EXEC} :protobuf-sources:generateBlockNodeProtoArtifact

      # Untar protobuf sources
      - name: Untar Protobuf Sources
        working-directory: protobuf-sources
        run: |
          mkdir -p proto
          BN_VERSION="${{ steps.versions.outputs.bn_version }}"
          # Remove -SNAPSHOT suffix if present for protobuf lookup
          PROTO_TAG="${BN_VERSION%-SNAPSHOT}"
          PROTO_TAG="${PROTO_TAG#v}"
          tar -xzf block-node-protobuf-${PROTO_TAG}.tgz -C proto

      - name: Install grpcurl
        run: |
          curl -L https://github.com/fullstorydev/grpcurl/releases/download/v1.8.7/grpcurl_1.8.7_linux_x86_64.tar.gz -o grpcurl.tar.gz
          sudo tar -xzf grpcurl.tar.gz -C /usr/local/bin grpcurl
          rm grpcurl.tar.gz

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # Verify the BN is getting blocks
      - name: Get ServerStatus from Block Node
        run: |
          # Call serverStatus once
          STATUS_JSON=$(grpcurl \
            -plaintext \
            -emit-defaults \
            -import-path protobuf-sources/proto \
            -proto block-node/api/node_service.proto \
            -d '{}' \
            localhost:40840 \
            org.hiero.block.api.BlockNodeService/serverStatus)

          # Extract values
          FIRST_AVAILABLE_BLOCK=$(echo "$STATUS_JSON" | jq -r '.firstAvailableBlock')
          LAST_AVAILABLE_BLOCK=$(echo "$STATUS_JSON" | jq -r '.lastAvailableBlock')

          echo "First available block is $FIRST_AVAILABLE_BLOCK"
          echo "Last available block is $LAST_AVAILABLE_BLOCK"

          # Validate
          if [[ "$FIRST_AVAILABLE_BLOCK" != "0" ]]; then
              echo "First available block is not 0"
              exit 1
          fi
          if (( LAST_AVAILABLE_BLOCK < 1 )); then
              echo "Last available block is less than 1"
              exit 1
          fi

          # Export for later steps
          echo "FIRST_AVAILABLE_BLOCK=$FIRST_AVAILABLE_BLOCK" >> $GITHUB_ENV
          echo "LAST_AVAILABLE_BLOCK=$LAST_AVAILABLE_BLOCK" >> $GITHUB_ENV

      # Wait for load generation to complete and blocks to be produced
      - name: Wait for load generation to complete
        run: |
          DURATION="${{ inputs.load-duration }}"
          # Parse duration (e.g., "5m" -> 300 seconds, "1h" -> 3600 seconds)
          if [[ "$DURATION" =~ ^([0-9]+)m$ ]]; then
            WAIT_SECONDS=$((${BASH_REMATCH[1]} * 60))
          elif [[ "$DURATION" =~ ^([0-9]+)h$ ]]; then
            WAIT_SECONDS=$((${BASH_REMATCH[1]} * 3600))
          elif [[ "$DURATION" =~ ^([0-9]+)s$ ]]; then
            WAIT_SECONDS=${BASH_REMATCH[1]}
          else
            # Default to 5 minutes if parsing fails
            WAIT_SECONDS=300
          fi

          # Add 30 seconds buffer for block propagation
          WAIT_SECONDS=$((WAIT_SECONDS + 30))

          # Minimum wait of 60 seconds
          if (( WAIT_SECONDS < 60 )); then
            WAIT_SECONDS=60
          fi

          echo "Waiting ${WAIT_SECONDS} seconds for load generation to complete..."
          sleep ${WAIT_SECONDS}

      - name: Get first block from Block Node
        run: |
          FIRST_BLOCK=$(grpcurl \
            -plaintext \
            -emit-defaults \
            -import-path protobuf-sources/proto \
            -proto block-node/api/block_access_service.proto \
            -d "{\"block_number\": $FIRST_AVAILABLE_BLOCK}" \
            localhost:40840 \
            org.hiero.block.api.BlockAccessService/getBlock \
            | jq -r '.block.items[0].blockHeader.number')
          if [ -z "FIRST_BLOCK" ]; then
            echo "Error: FIRST_BLOCK is empty"
            exit 1
          fi
          echo "FirstBlock is ${FIRST_BLOCK}"

      - name: Get last block from Block Node
        run: |
          LAST_BLOCK=$(grpcurl \
            -plaintext \
            -emit-defaults \
            -import-path protobuf-sources/proto \
            -proto block-node/api/block_access_service.proto \
            -d "{\"block_number\": $LAST_AVAILABLE_BLOCK}" \
            localhost:40840 \
            org.hiero.block.api.BlockAccessService/getBlock \
            | jq -r '.block.items[0].blockHeader.number')
          if [ -z "LAST_BLOCK" ]; then
            echo "Error: LAST_BLOCK is empty"
            exit 1
          fi
          echo "LastBlock is ${LAST_BLOCK}"

      - name: Validate first block on Mirror Node
        run: |
          # Fetch the block number from Mirror Node
          FIRST_BLOCK_MIRROR=$(curl -s "http://127.0.0.1:5551/api/v1/blocks/$FIRST_AVAILABLE_BLOCK" | jq -r '.number')

          # Check if we got a value
          if [ -z "$FIRST_BLOCK_MIRROR" ]; then
            echo "Error: FIRST_BLOCK_MIRROR is empty"
            exit 1
          fi

          echo "FIRST_BLOCK_MIRROR is $FIRST_BLOCK_MIRROR"
          echo "FIRST_AVAILABLE_BLOCK is $FIRST_AVAILABLE_BLOCK"

          # Validate that the Mirror Node block matches the Block Node first block
          if [ "$FIRST_BLOCK_MIRROR" != "$FIRST_AVAILABLE_BLOCK" ]; then
            echo "Error: Mirror Node first block ($FIRST_BLOCK_MIRROR) does not match Block Node first block ($FIRST_AVAILABLE_BLOCK)"
            exit 1
          fi

          echo "Mirror Node first block matches Block Node first block"

      - name: Validate last block on Mirror Node
        run: |
          # Fetch the block number from Mirror Node
          LAST_BLOCK_MIRROR=$(curl -s "http://127.0.0.1:5551/api/v1/blocks/$LAST_AVAILABLE_BLOCK" | jq -r '.number')

          # Check if we got a value
          if [ -z "$LAST_BLOCK_MIRROR" ]; then
              echo "Error: LAST_BLOCK_MIRROR is empty"
              exit 1
          fi

          echo "LAST_BLOCK_MIRROR is $LAST_BLOCK_MIRROR"
          echo "LAST_AVAILABLE_BLOCK is $LAST_AVAILABLE_BLOCK"

          # Validate that the Mirror Node block matches the Block Node last block
          if [ "$LAST_BLOCK_MIRROR" != "$LAST_AVAILABLE_BLOCK" ]; then
              echo "Error: Mirror Node last block ($LAST_BLOCK_MIRROR) does not match Block Node last block ($LAST_AVAILABLE_BLOCK)"
              exit 1
          fi

          echo "Mirror Node last block matches Block Node last block"

      # TCK Regression Tests related steps
      - name: Setup PNPM
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          npm install -g pnpm

      - name: Checkout Regression Code
        if: ${{ inputs.run-tck-regression-tests }}
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          path: sdk-tck/regression
          repository: hiero-ledger/hiero-sdk-tck
          fetch-depth: 0
          fetch-tags: true

      - name: Checkout Latest Tag (TCK)
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          cd sdk-tck/regression
          git fetch --tags
          LATEST_TAG=$(git describe --tags `git rev-list --tags --max-count=1`)
          echo "Latest TCK tag: $LATEST_TAG"
          git checkout $LATEST_TAG

      # Checkout the JS-SDK server
      - name: Checkout JS-SDK Server
        if: ${{ inputs.run-tck-regression-tests }}
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          path: sdk-tck/sdk-server
          repository: hiero-ledger/hiero-sdk-js
          fetch-depth: 0
          fetch-tags: true

      - name: Checkout Latest Tag (JS-SDK)
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          cd sdk-tck/sdk-server
          git fetch --tags
          LATEST_TAG=$(git describe --tags `git rev-list --tags --max-count=1`)
          echo "Latest JS-SDK tag: $LATEST_TAG"
          git checkout $LATEST_TAG

      # Set up the npm dependencies and cache on the tck-client
      - name: Set up the tck-client
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          npm cache clean --force
          npm install
        working-directory: sdk-tck/regression

      # Set up the npm dependencies and cache on the sdk-server
      - name: Install NodeJS Dependencies (sdk-server)
        if: ${{ inputs.run-tck-regression-tests }}
        id: start-sdk-server
        run: |
          # Extract package versions from the parent package.json
          SDK_VERSION=$(node -e "console.log(require('../package.json').version)")
          LONG_VERSION=$(node -e "console.log(require('../package.json').dependencies.long)")
          PROTO_VERSION=$(node -e "console.log(require('../package.json').dependencies['@hashgraph/proto'])")

          echo "Using SDK version: $SDK_VERSION"
          echo "Using long version: $LONG_VERSION"
          echo "Using proto version: $PROTO_VERSION"

          # Install with the extracted versions
          pnpm add @hashgraph/sdk@^${SDK_VERSION} long@${LONG_VERSION} @hashgraph/proto@${PROTO_VERSION}
          pnpm install
          nohup pnpm start &
          server_pid=$!
          echo "pid=${server_pid}" >> "${GITHUB_OUTPUT}"
        working-directory: sdk-tck/sdk-server/tck

      # Start the TCK client
      - name: Start tck-client
        if: ${{ inputs.run-tck-regression-tests }}
        env:
          OPERATOR_ACCOUNT_ID: "0.0.2"
          OPERATOR_ACCOUNT_PRIVATE_KEY: "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137"
          JSON_RPC_SERVER_URL: "http://127.0.0.1:8544"
          NODE_IP: "127.0.0.1:50211"
          MIRROR_NODE_REST_URL: "http://127.0.0.1:5551"
          MIRROR_NODE_REST_JAVA_URL: "http://127.0.0.1:8084"
        run: |
          solo ledger account create --dev --ed25519-private-key "${{ env.OPERATOR_ACCOUNT_PRIVATE_KEY }}" --deployment "${DEPLOYMENT}" --hbar-amount 1000000
          cp .env.custom_node .env
          npm run test:file src/tests/contract-service/test-contract-execute-transaction.ts
        working-directory: sdk-tck/regression # required

      - name: BN Based - SDK TCK Regression Test Report
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: ${{ !cancelled()  &&  inputs.run-tck-regression-tests }}
        with:
          name: SDK TCK Regression Test Report
          path: "**/sdk-tck/regression/mochawesome-report/mochawesome.*"
          retention-days: 7

      # Stop load generator if it was started
      - name: Stop NLG Load Generation
        if: ${{ always() && inputs.load-tps != '0' }}
        continue-on-error: true
        run: |
          ./.github/workflows/support/scripts/solo-load-generate.sh \
            --deployment "${DEPLOYMENT}" \
            --action stop || true

      - name: Collect BN and MN Logs
        if: always()
        run: |
          # Get BN Logs
          kubectl logs -n "${NAMESPACE}" -l "app.kubernetes.io/name=block-node-1" --all-containers --since=24h --timestamps --prefix --tail=-1 > bn0-logs.log

          # Get MN Logs
          kubectl logs -n "${NAMESPACE}" -l "app.kubernetes.io/instance=mirror-1,app.kubernetes.io/component=importer" --all-containers --since=24h --timestamps --prefix --tail=-1 > mn0-logs.log

      - name: Collect CN Logs
        if: always()
        run: |
          # Get CN Logs
          solo consensus diagnostics all --dev --deployment "${DEPLOYMENT}"
          BASE="${HOME}/.solo/logs/${NAMESPACE}"
          LOG_FOLDER=$(ls -1d "$BASE"/* | sort -r | head -n1)
          echo "Latest log folder is $LOG_FOLDER"
          echo "CN_LOG_FOLDER=$LOG_FOLDER" >> $GITHUB_ENV
          ls -lR "$LOG_FOLDER"

      - name: List CN logs
        if: always()
        run: ls -lR "${{ env.CN_LOG_FOLDER }}"

      - name: Upload CN Logs
        if: always()
        id: upload_logs_cn
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: cn-logs
          path: ${{ env.CN_LOG_FOLDER }}/*.zip

      - name: Upload Logs
        if: always()
        id: upload_logs_bn_mn
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: BN-MN-logs
          path: |
            bn0-logs.log
            mn0-logs.log

      - name: Add Logs to Summary
        if: always()
        run: |
          {
            echo "### Logs"
            echo ""
            echo "You can download the logs from this run here:"
            echo "- [Download BN-MN-logs](${{ steps.upload_logs_bn_mn.outputs.artifact-url }})"
            echo "- [Download CN-logs](${{ steps.upload_logs_cn.outputs.artifact-url }})"

          } >> "$GITHUB_STEP_SUMMARY"

      # Stop the TCK Tests server
      - name: Stop TCK Test Server
        if: ${{ inputs.run-tck-regression-tests }}
        run: |
          echo ${{ steps.start-sdk-server.outputs.pid }}
          kill -9 ${{ steps.start-sdk-server.outputs.pid }}

      # Stop the solo nodes
      - name: Stop solo
        if: ${{ always() }}
        run: |
          kind delete cluster -n ${{ env.CLUSTER_NAME }}
