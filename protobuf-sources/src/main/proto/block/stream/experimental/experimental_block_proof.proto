/**
 * # Block Proof
 * A proof for the block streamed from a consensus node.
 *
 * ### Keywords
 * The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
 * "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
 * document are to be interpreted as described in
 * [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
 * [RFC8174](https://www.ietf.org/rfc/rfc8174).
 */
syntax = "proto3";

package com.hedera.hapi.block.stream.experimental;

// SPDX-License-Identifier: Apache-2.0
option java_package = "com.hedera.hapi.block.stream.experimental.protoc";
// <<<pbj.java_package = "com.hedera.hapi.block.stream.experimental">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

/**
 * A cryptographic proof for the "Block Merkle Tree".
 *
 * This message SHALL offer a proof for the "Block Merkle Tree".
 * The information in the "Block Merkle Tree" SHALL be used to validate the
 * full content of the most recent block, and, with chained validation,
 * all prior blocks.
 *
 * ### Block Merkle Tree
 * The Block Hash of any block is a merkle root hash comprised of a 4 leaf
 * binary merkle tree. The 4 leaves represent
 * 1. Previous block proof hash
 * 1. Merkle root of transaction inputs tree
 * 1. Merkle root of transaction outputs tree
 * 1. Merkle rook of state tree
 *
 * #### Computing the hash
 * The process for computing a block hash is somewhat complex, and involves
 * creating a "virtual" merkle tree to obtain the root merkle hash of
 * that virtual tree.<br/>
 * The merkle tree SHALL have a 4 part structure with 2 internal nodes,
 * structured in a strictly binary tree.
 * - The merkle tree root SHALL be the parent of both
 *   internal nodes.
 *    1. The first "internal" node SHALL be the parent of the
 *       two "left-most" nodes.
 *       1. The first leaf MUST be the previous block hash, and is a
 *          single 48-byte value.
 *       1. The second leaf MUST be the root of a, strictly binary, merkle tree
 *          composed of all "input" block items in the block.<br/>
 *          Input items SHALL be transactions, system transactions,
 *          and events.<br/>
 *          Leaf nodes in this subtree SHALL be ordered in the same order
 *          that the block items are encountered in the stream.
 *    1. The second "internal" node SHALL be the parent of the two
 *       "right-most" nodes.
 *       1. The third leaf MUST be the root of a, strictly binary, merkle tree
 *          composed of all "output" block items in the block.<br/>
 *          Output items SHALL be transaction result, transaction
 *          output, and state changes.<br/>
 *          Leaf nodes in this subtree SHALL be ordered in the same order that
 *          the block items are encountered in the stream.
 *       1. The fourth leaf MUST be the merkle tree root hash for network state
 *          at the start of the block, and is a single 48-byte value.
 * - The block hash SHALL be the hash calculated for the root of this merkle
 *   tree.
 * - The hash algorithm used SHALL be the algorithm specified in the
 *   corresponding block header.
 *
 * The "inputs" and "outputs" subtrees SHALL be "complete" binary merkle trees,
 * with nodes that would otherwise be missing replaced by a "null" hash
 * leaf.
 */
message BlockProof {
    oneof proof {
        TssSignedBlockProof signed_block_proof = 1;
        //StateProof block_state_proof = 2;
        SignedRecordFileProof signed_record_file_proof = 3;
    }
}
message TssSignedBlockProof {
    bytes block_signature = 4;
}
message SignedRecordFileProof {
    /**
     * The record file format version, this dictates how the hash that is signed
     * is computed. Valid versions are 2, 5 and 6.
     */
    uint32 version = 1;
    /**
     * A collection of RSA signatures from consensus nodes.<br/>
     * These signatures validate the hash of the record_file_contents field.
     */
    repeated RecordFileSignature record_file_signatures = 2;
}

/**
 * A signature by a node on the SHA384 hash of the record file.
 */
message RecordFileSignature {
    /**
     * A single RSA signature.<br/>
     * This is the RSA signature of the node on the SHA384 hash of
     * the record file
     */
    bytes signatures_bytes = 1;

    /**
     * A unique node identifier.<br/>
     * This is the node id of the consensus node that created this signature.
     */
    uint64 node_id = 2;
}
