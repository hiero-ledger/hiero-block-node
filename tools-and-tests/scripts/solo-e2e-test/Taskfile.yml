# SPDX-License-Identifier: Apache-2.0
# Solo E2E Test Taskfile - Local development helper for Hiero network deployments
#
# Prerequisites:
#   - Docker (for Kind)
#   - kubectl
#   - helm
#   - kind
#   - solo CLI (npm i @hashgraph/solo -g)
#   - grpcurl (optional, for verification)
#
# Quick start:
#   1. Copy .env.example to .env and set TOPOLOGY (optional)
#   2. Run: task up
#   3. When done: task down
#
# Configuration (via .env or environment):
#   TOPOLOGY      - Network topology (default: single)
#   CLUSTER_NAME  - Kind cluster name (default: solo-cluster)
#   CN_VERSION    - Consensus Node version (default: latest)
#   MN_VERSION    - Mirror Node version (default: latest)
#   BN_VERSION    - Block Node version (default: latest)
#   NLG_CONCURRENCY - NLG -c parameter (default: 5)
#   NLG_ACCOUNTS    - NLG -a parameter (default: 10)
#   NLG_DURATION    - NLG -t parameter in seconds (default: 300)
#   NLG_MAX_TPS     - NLG --max-tps parameter (optional)

version: '3'

dotenv: ['.env']

vars:
  # Paths (relative to this Taskfile)
  SCRIPTS_DIR: "{{.ROOT_DIR}}/scripts"
  TOPOLOGIES_DIR: "{{.ROOT_DIR}}/topologies"
  TOPOLOGY_TOOL: "{{.ROOT_DIR}}/../network-topology-tool"
  PROTO_PATH: "{{.ROOT_DIR}}/../../../protobuf-sources/build/proto"

  # Config with defaults (override via .env or environment)
  TOPOLOGY: '{{.TOPOLOGY | default "single"}}'
  CLUSTER_NAME: '{{.CLUSTER_NAME | default "solo-cluster"}}'
  NAMESPACE: '{{.NAMESPACE | default "solo-network"}}'
  DEPLOYMENT: '{{.DEPLOYMENT | default "deployment-solo"}}'
  CLUSTER_REF: 'kind-{{.CLUSTER_NAME}}'

  # Version defaults
  CN_VERSION: '{{.CN_VERSION | default "latest"}}'
  MN_VERSION: '{{.MN_VERSION | default "latest"}}'
  BN_VERSION: '{{.BN_VERSION | default "latest"}}'

  # NLG load generation parameters (direct, no TPS abstraction)
  NLG_TEST_CLASS: '{{.NLG_TEST_CLASS | default "CryptoTransferLoadTest"}}'
  NLG_CONCURRENCY: '{{.NLG_CONCURRENCY | default "5"}}'
  NLG_ACCOUNTS: '{{.NLG_ACCOUNTS | default "10"}}'
  NLG_DURATION: '{{.NLG_DURATION | default "300"}}'
  NLG_EXTRA_ARGS: '{{.NLG_EXTRA_ARGS | default ""}}'
  NLG_MAX_TPS: '{{.NLG_MAX_TPS | default ""}}'

  # Metrics/Observability
  ENABLE_LOCAL_METRICS: '{{.ENABLE_LOCAL_METRICS | default "false"}}'

  # TCK-SDK test configuration
  TCK_SDK_DIR: '{{.TCK_SDK_DIR | default "sdk-tck"}}'
  TCK_TEST_FILE: '{{.TCK_TEST_FILE | default "src/tests/crypto-service/test-transfer-transaction.ts"}}'

tasks:
  # ============================================================================
  # Prerequisites
  # ============================================================================
  check:
    desc: Check all prerequisites are installed
    cmds:
      - |
        echo "Checking prerequisites..."
        command -v docker >/dev/null 2>&1 || { echo "ERROR: docker not found"; exit 1; }
        command -v kubectl >/dev/null 2>&1 || { echo "ERROR: kubectl not found"; exit 1; }
        command -v helm >/dev/null 2>&1 || { echo "ERROR: helm not found"; exit 1; }
        command -v kind >/dev/null 2>&1 || { echo "ERROR: kind not found"; exit 1; }
        command -v solo >/dev/null 2>&1 || { echo "ERROR: solo not found. Install with: npm i @hashgraph/solo -g"; exit 1; }
        echo "All prerequisites found!"
        echo ""
        echo "Versions:"
        echo "  Docker: $(docker --version)"
        echo "  kubectl: $(kubectl version --client --short 2>/dev/null || kubectl version --client)"
        echo "  Helm: $(helm version --short)"
        echo "  Kind: $(kind --version)"
        echo "  Solo: $(solo --version)"
    silent: true

  # ============================================================================
  # Cluster Lifecycle
  # ============================================================================
  cluster:create:
    desc: Create Kind cluster with Solo initialization
    cmds:
      - task: check
      - |
        "{{.SCRIPTS_DIR}}/solo-setup-cluster.sh" \
          --cluster-name "{{.CLUSTER_NAME}}" \
          --namespace "{{.NAMESPACE}}" \
          --deployment "{{.DEPLOYMENT}}" \
          --topology "{{.TOPOLOGY}}" \
          --topologies-dir "{{.TOPOLOGIES_DIR}}"

  cluster:destroy:
    desc: Destroy Kind cluster and clean up Solo config
    cmds:
      - |
        echo "Cleaning up Solo local config..."
        solo deployment config delete -d "{{.DEPLOYMENT}}" -q 2>/dev/null || true
        solo cluster-ref config disconnect -c "{{.CLUSTER_REF}}" -q 2>/dev/null || true

        # Fallback: if Solo CLI failed, clean config directly with yq
        if yq -e '.deployments[] | select(.name == "{{.DEPLOYMENT}}")' ~/.solo/local-config.yaml >/dev/null 2>&1; then
          echo "Solo CLI cleanup incomplete, removing stale config entry..."
          yq -i 'del(.deployments[] | select(.name == "{{.DEPLOYMENT}}"))' ~/.solo/local-config.yaml 2>/dev/null || true
          yq -i 'del(.clusterRefs["{{.CLUSTER_REF}}"])' ~/.solo/local-config.yaml 2>/dev/null || true
        fi

        echo "Destroying Kind cluster '{{.CLUSTER_NAME}}'..."
        kind delete cluster -n "{{.CLUSTER_NAME}}" || true
        echo "Cluster and Solo config cleaned up."

  # ============================================================================
  # Network Deployment
  # ============================================================================
  network:deploy:
    desc: Deploy network using configured topology
    silent: true
    cmds:
      - |
        # Resolve versions (latest -> actual GA versions)
        VERSIONS=$("{{.SCRIPTS_DIR}}/resolve-versions.sh" "{{.CN_VERSION}}" "{{.MN_VERSION}}" "{{.BN_VERSION}}")

        # Parse resolved versions
        CN_RESOLVED=$(echo "$VERSIONS" | grep "^cn_version=" | cut -d= -f2)
        MN_RESOLVED=$(echo "$VERSIONS" | grep "^mn_version=" | cut -d= -f2)
        BN_RESOLVED=$(echo "$VERSIONS" | grep "^bn_version=" | cut -d= -f2)

        "{{.SCRIPTS_DIR}}/solo-deploy-network.sh" \
          --deployment "{{.DEPLOYMENT}}" \
          --namespace "{{.NAMESPACE}}" \
          --cluster-ref "{{.CLUSTER_REF}}" \
          --topology "{{.TOPOLOGY}}" \
          --topologies-dir "{{.TOPOLOGIES_DIR}}" \
          --cn-version "$CN_RESOLVED" \
          --mn-version "$MN_RESOLVED" \
          --bn-version "$BN_RESOLVED" \
          {{if eq .ENABLE_LOCAL_METRICS "true"}}--enable-metrics{{end}}

  # ============================================================================
  # Port Forwarding
  # ============================================================================
  port-forward:
    desc: Set up port forwards for local access
    cmds:
      - '"{{.SCRIPTS_DIR}}/solo-port-forward.sh" --namespace "{{.NAMESPACE}}"'

  port-forward:stop:
    desc: Stop all port forwards
    cmds:
      - |
        echo "Stopping port forwards..."
        pkill -f "kubectl port-forward" 2>/dev/null || true
        echo "Port forwards stopped."

  # ============================================================================
  # Verification
  # ============================================================================
  verify:
    desc: "Verify Block Node is receiving blocks (NODE=n for specific node, default: 1)"
    deps: [proto:extract]
    vars:
      NODE: '{{.NODE | default "1"}}'
    cmds:
      - |
        PORT=$((40839 + {{.NODE}}))
        echo "Verifying Block Node {{.NODE}} on localhost:${PORT}..."
        if ! command -v grpcurl >/dev/null 2>&1; then
          echo "ERROR: grpcurl not found. Install from: https://github.com/fullstorydev/grpcurl"
          exit 1
        fi

        STATUS=$(grpcurl -plaintext -max-msg-sz 104857600 \
          -import-path "{{.PROTO_PATH}}" \
          -proto block-node/api/node_service.proto \
          localhost:${PORT} org.hiero.block.api.BlockNodeService/serverStatus 2>&1) || {
          echo "ERROR: Could not connect to Block Node. Is port-forward running?"
          echo "Run: task port-forward"
          exit 1
        }

        echo "Block Node {{.NODE}} Status:"
        echo "$STATUS" | grep -E "(firstAvailableBlock|lastAvailableBlock)" || echo "$STATUS"

  status:
    desc: Show network status for all nodes in the topology
    deps: [proto:extract]
    cmds:
      - '"{{.SCRIPTS_DIR}}/solo-network-status.sh" --namespace "{{.NAMESPACE}}" --topology "{{.TOPOLOGY}}" --topologies-dir "{{.TOPOLOGIES_DIR}}" --context "{{.CLUSTER_REF}}" --proto-path "{{.PROTO_PATH}}"'

  metrics:
    desc: "Show Block Node metrics summary (NODE=n for specific node, NODE=all for all nodes)"
    vars:
      NODE: '{{.NODE | default "1"}}'
    cmds:
      - |
        if [[ "{{.NODE}}" == "all" ]]; then
          # Get all block nodes from topology
          TOPOLOGY_FILE="{{.TOPOLOGIES_DIR}}/{{.TOPOLOGY}}.yaml"
          BLOCK_NODES=$(grep -E '^[[:space:]]+block-node-[0-9]+:' "${TOPOLOGY_FILE}" 2>/dev/null | sed 's/://g' | awk '{print $1}' || echo "block-node-1")
          PORT=16007
          for bn in ${BLOCK_NODES}; do
            echo "=== ${bn} Metrics ==="
            "{{.SCRIPTS_DIR}}/solo-metrics-summary.sh" ${PORT} text || echo "Metrics unavailable for ${bn}"
            echo ""
            PORT=$((PORT + 1))
          done
        else
          PORT=$((16006 + {{.NODE}}))
          echo "=== block-node-{{.NODE}} Metrics ==="
          "{{.SCRIPTS_DIR}}/solo-metrics-summary.sh" ${PORT} text
        fi

  # ============================================================================
  # Logs
  # ============================================================================
  logs:bn:
    desc: "View Block Node logs (NODE=n for specific node, default: 1)"
    vars:
      NODE: '{{.NODE | default "1"}}'
    cmds:
      - kubectl logs -n "{{.NAMESPACE}}" -l "app.kubernetes.io/name=block-node-{{.NODE}}" --all-containers -f

  # ============================================================================
  # Load Generation
  # ============================================================================
  load:up:
    desc: "Start NLG (NLG_CONCURRENCY, NLG_ACCOUNTS, NLG_DURATION, NLG_EXTRA_ARGS)"
    env:
      DEPLOYMENT: "{{.DEPLOYMENT}}"
      NAMESPACE: "{{.NAMESPACE}}"
      NLG_TEST_CLASS: "{{.NLG_TEST_CLASS}}"
      NLG_CONCURRENCY: "{{.NLG_CONCURRENCY}}"
      NLG_ACCOUNTS: "{{.NLG_ACCOUNTS}}"
      NLG_DURATION: "{{.NLG_DURATION}}"
      NLG_EXTRA_ARGS: "{{.NLG_EXTRA_ARGS}}"
      NLG_MAX_TPS: "{{.NLG_MAX_TPS}}"
    cmds:
      - '"{{.SCRIPTS_DIR}}/solo-load-generate.sh" start'

  load:down:
    desc: Stop NLG load generation
    env:
      DEPLOYMENT: "{{.DEPLOYMENT}}"
      NAMESPACE: "{{.NAMESPACE}}"
      NLG_TEST_CLASS: "{{.NLG_TEST_CLASS}}"
    cmds:
      - '"{{.SCRIPTS_DIR}}/solo-load-generate.sh" stop'

  # ============================================================================
  # Main Tasks
  # ============================================================================
  up:
    desc: Full setup - create cluster, deploy network, start port-forwards
    cmds:
      - task: cluster:create
      - task: network:deploy
      - task: port-forward
      - |
        echo ""
        echo "=========================================="
        echo "Network is up and running!"
        echo "=========================================="
        echo ""
        echo "Topology: {{.TOPOLOGY}}"
        echo ""
        echo "Useful commands:"
        echo "  task verify     - Check Block Node status"
        echo "  task logs:bn    - View Block Node logs"
        echo "  task load:up    - Start load generation"
        echo "  task down       - Tear down everything"

  down:
    desc: Tear down everything - stop port-forwards and destroy cluster
    cmds:
      - task: port-forward:stop
      - task: cluster:destroy
      - |
        echo ""
        echo "All resources cleaned up."

  # ============================================================================
  # Test Framework
  # ============================================================================
  proto:extract:
    desc: Extract proto files for local testing (auto-runs before tests)
    silent: true
    cmds:
      - |
        PROTO_DIR="{{.PROTO_PATH}}"
        if [[ ! -d "$PROTO_DIR/services" ]]; then
          echo "Extracting proto files to $PROTO_DIR..."
          mkdir -p "$PROTO_DIR"
          TARBALL=$(ls "{{.ROOT_DIR}}/../../../protobuf-sources/block-node-protobuf-"*.tgz 2>/dev/null | head -1)
          if [[ -z "$TARBALL" ]]; then
            echo "ERROR: No proto tarball found in protobuf-sources/"
            echo "Run: ./gradlew :protobuf-sources:assemble"
            exit 1
          fi
          tar -xzf "$TARBALL" -C "$PROTO_DIR"
          echo "Proto files extracted from $(basename "$TARBALL")"
        else
          echo "Proto files already extracted at $PROTO_DIR"
        fi

  test:run:
    desc: "Run a test definition (TEST_FILE=tests/basic-load.yaml)"
    deps: [proto:extract]
    vars:
      TEST_FILE: '{{.TEST_FILE | default "tests/smoke-test.yaml"}}'
    cmds:
      - |
        "{{.SCRIPTS_DIR}}/solo-test-runner.sh" \
          --test "{{.TEST_FILE}}" \
          --topology "{{.TOPOLOGY}}" \
          --namespace "{{.NAMESPACE}}" \
          --context "{{.CLUSTER_REF}}" \
          --topologies-dir "{{.TOPOLOGIES_DIR}}" \
          --proto-path "{{.PROTO_PATH}}"

  test:validate:
    desc: "Validate a test definition file (TEST_FILE=tests/basic-load.yaml)"
    vars:
      TEST_FILE: '{{.TEST_FILE | default "tests/smoke-test.yaml"}}'
    cmds:
      - |
        "{{.SCRIPTS_DIR}}/solo-test-runner.sh" \
          --test "{{.TEST_FILE}}" \
          --topology "{{.TOPOLOGY}}" \
          --topologies-dir "{{.TOPOLOGIES_DIR}}" \
          --validate

  test:list:
    desc: List available test definitions
    cmds:
      - |
        echo "Available test definitions:"
        echo ""
        ls -la "{{.ROOT_DIR}}/tests/"*.yaml 2>/dev/null || echo "No test files found in tests/"
        echo ""
        echo "Run a test with: task test:run TEST_FILE=tests/<name>.yaml"

  # ============================================================================
  # TCK-SDK Tests (matches consensus-node approach: uses latest tags)
  # ============================================================================
  tck:clone:
    desc: Clone TCK and JS-SDK repositories and checkout latest tags
    cmds:
      - |
        # Clone and checkout latest tag for TCK
        if [[ ! -d "{{.TCK_SDK_DIR}}/regression" ]]; then
          echo "Cloning TCK repository..."
          git clone https://github.com/hiero-ledger/hiero-sdk-tck.git \
            "{{.TCK_SDK_DIR}}/regression"
        fi
        cd "{{.TCK_SDK_DIR}}/regression"
        git fetch --tags
        LATEST_TAG=$(git describe --tags --abbrev=0)
        echo "Checking out TCK latest tag: $LATEST_TAG"
        git checkout "$LATEST_TAG"

        # Clone and checkout latest tag for JS-SDK
        cd - > /dev/null
        if [[ ! -d "{{.TCK_SDK_DIR}}/sdk-server" ]]; then
          echo "Cloning JS-SDK repository..."
          git clone https://github.com/hiero-ledger/hiero-sdk-js.git \
            "{{.TCK_SDK_DIR}}/sdk-server"
        fi
        cd "{{.TCK_SDK_DIR}}/sdk-server"
        git fetch --tags
        LATEST_TAG=$(git describe --tags --abbrev=0)
        echo "Checking out JS-SDK latest tag: $LATEST_TAG"
        git checkout "$LATEST_TAG"

  tck:check:
    desc: Check if TCK-SDK dependencies are installed
    cmds:
      - |
        "{{.SCRIPTS_DIR}}/solo-tck-sdk-check.sh" \
          --sdk-dir "{{.TCK_SDK_DIR}}/sdk-server"

  tck:install:
    desc: Install TCK-SDK dependencies (run after tck:clone)
    deps: [tck:clone]
    cmds:
      - |
        "{{.SCRIPTS_DIR}}/solo-tck-sdk-install.sh" \
          --sdk-dir "{{.TCK_SDK_DIR}}/sdk-server" \
          --tck-dir "{{.TCK_SDK_DIR}}/regression"

  test:tck-sdk:
    desc: Run TCK-SDK regression test (requires network up)
    cmds:
      - |
        # Check if repos are cloned
        if [[ ! -d "{{.TCK_SDK_DIR}}/regression" ]] || [[ ! -d "{{.TCK_SDK_DIR}}/sdk-server" ]]; then
          echo "TCK repositories not cloned. Running tck:clone first..."
          task tck:clone
        fi

        # Check if deps installed, install if needed
        "{{.SCRIPTS_DIR}}/solo-tck-sdk-check.sh" \
          --sdk-dir "{{.TCK_SDK_DIR}}/sdk-server" || \
        "{{.SCRIPTS_DIR}}/solo-tck-sdk-install.sh" \
          --sdk-dir "{{.TCK_SDK_DIR}}/sdk-server" \
          --tck-dir "{{.TCK_SDK_DIR}}/regression"

        # Run the test
        "{{.SCRIPTS_DIR}}/solo-tck-sdk-run.sh" \
          --sdk-dir "{{.TCK_SDK_DIR}}/sdk-server" \
          --tck-dir "{{.TCK_SDK_DIR}}/regression" \
          --test-file "{{.TCK_TEST_FILE}}" \
          --deployment "{{.DEPLOYMENT}}" \
          --namespace "{{.NAMESPACE}}"
