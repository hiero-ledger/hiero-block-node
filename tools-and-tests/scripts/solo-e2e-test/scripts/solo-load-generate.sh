#!/usr/bin/env bash
# SPDX-License-Identifier: Apache-2.0
#
# Solo E2E Test - NLG Load Generation Script
#
# Usage: solo-load-generate.sh [start|stop]
#
# Environment variables:
#   DEPLOYMENT       Solo deployment name (required)
#   NAMESPACE        Kubernetes namespace (default: solo-network)
#   NLG_TEST_TYPE    Test class (default: CryptoTransferLoadTest)
#                    Options: CryptoTransferLoadTest, HCSLoadTest, TokenTransferLoadTest, NftTransferLoadTest
#   NLG_ARGS         NLG arguments string (e.g., "-c 5 -a 10 -tt 300")
#   NLG_MAX_TPS      --max-tps parameter (optional)
#
# Examples:
#   DEPLOYMENT=my-deploy ./solo-load-generate.sh start
#   DEPLOYMENT=my-deploy NLG_TEST_TYPE=HCSLoadTest NLG_ARGS="-c 10 -a 20 -tt 60" ./solo-load-generate.sh start
#   DEPLOYMENT=my-deploy ./solo-load-generate.sh stop

set -euo pipefail

# Action (start or stop)
ACTION="${1:-start}"

# Required
DEPLOYMENT="${DEPLOYMENT:?DEPLOYMENT environment variable is required}"

# Defaults
NAMESPACE="${NAMESPACE:-solo-network}"
TEST_CLASS="${NLG_TEST_TYPE:-CryptoTransferLoadTest}"
NLG_ARGS="${NLG_ARGS:--c 5 -a 10 -tt 300}"
MAX_TPS="${NLG_MAX_TPS:-}"

# Temporary directory for generated files
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TMP_DIR="${SCRIPT_DIR}/../.tmp"
mkdir -p "$TMP_DIR"

# Generate NLG values file with CN IP addresses
# This follows the pattern from hiero-consensus-node CITR workflow:
# https://github.com/hiero-ledger/hiero-consensus-node/.github/workflows/zxc-single-day-longevity-test.yaml
generate_nlg_values() {
    local values_file="$TMP_DIR/nlg-values.yaml"

    # Note: All diagnostic messages go to stderr so only the file path is returned via stdout
    echo "Discovering Consensus Node IPs..." >&2

    # Get network-node services with their CLUSTER-IPs and account IDs
    # Label: solo.hedera.com/type=network-node-svc
    local services
    services=$(kubectl get svc -n "$NAMESPACE" \
        -l "solo.hedera.com/type=network-node-svc" \
        -o jsonpath='{range .items[*]}{.spec.clusterIP}{" "}{.metadata.labels.solo\.hedera\.com/account-id}{"\n"}{end}' 2>/dev/null || true)

    if [[ -z "$services" ]]; then
        echo "WARNING: No Consensus Node services found with label solo.hedera.com/type=network-node-svc" >&2
        echo "NLG will use default network discovery" >&2
        # Return empty string - no values file to use
        # Note: This is not an error - NLG can discover nodes via other means
        return 0
    fi

    # Generate the values file with network properties
    cat > "$values_file" << 'YAML_HEADER'
# Auto-generated NLG values file with CN network properties
# Generated by solo-load-generate.sh
loadGenerator:
  test:
    properties:
YAML_HEADER

    # Add each CN's IP:port=account-id mapping
    local count=0
    while IFS=' ' read -r ip account_id; do
        if [[ -n "$ip" && -n "$account_id" ]]; then
            # Format: '10.96.1.2\:50211=0.0.3'
            # The backslash escapes the colon in YAML
            echo "      - '${ip}\\:50211=${account_id}'" >> "$values_file"
            echo "  Found CN: ${ip}:50211 -> ${account_id}" >&2
            ((count++))
        fi
    done <<< "$services"

    echo "  Total CNs discovered: $count" >&2

    if [[ $count -eq 0 ]]; then
        # No valid entries, remove the file
        rm -f "$values_file"
        # Return empty string
        return
    fi

    # Only output the file path to stdout (for capture by caller)
    echo "$values_file"
}

# Handle stop action
if [[ "$ACTION" == "stop" ]]; then
    echo "Stopping NLG load generation..."
    echo "  Deployment: $DEPLOYMENT"
    echo "  Test class: $TEST_CLASS"

    # Try Solo's stop command first
    if solo rapid-fire load stop \
        --deployment "$DEPLOYMENT" \
        --test "$TEST_CLASS" \
        --quiet-mode 2>/dev/null; then
        echo "Solo stop command succeeded"
    else
        echo "Solo stop command failed, cleaning up directly..."
        # Fallback: clean up NLG resources directly
        # This handles cases where the NLG container crashed or is unresponsive

        # Delete the Helm release if it exists
        if helm status network-load-generator -n "$NAMESPACE" &>/dev/null; then
            echo "  Uninstalling Helm release..."
            helm uninstall network-load-generator -n "$NAMESPACE" 2>/dev/null || true
        fi

        # Force delete any remaining deployments
        if kubectl get deployment network-load-generator -n "$NAMESPACE" &>/dev/null; then
            echo "  Deleting deployment..."
            kubectl delete deployment network-load-generator -n "$NAMESPACE" --grace-period=0 --force 2>/dev/null || true
        fi

        # Clean up any orphaned pods
        kubectl delete pod -n "$NAMESPACE" -l app.kubernetes.io/name=network-load-generator --grace-period=0 --force 2>/dev/null || true

        echo "Direct cleanup completed"
    fi

    # Clean up generated values file
    rm -f "$TMP_DIR/nlg-values.yaml"

    echo "load_stopped=true"
    exit 0
fi

# Validate action
if [[ "$ACTION" != "start" ]]; then
    echo "ERROR: Action must be 'start' or 'stop', got: $ACTION" >&2
    exit 1
fi

echo "Starting NLG load generation..."
echo "  Deployment:  $DEPLOYMENT"
echo "  Test class:  $TEST_CLASS"
echo "  NLG args:    $NLG_ARGS"
[[ -n "$MAX_TPS" ]] && echo "  Max TPS:     $MAX_TPS"

# Generate values file with CN network properties
VALUES_FILE=$(generate_nlg_values)

# Build the Solo command
SOLO_CMD=(
    solo rapid-fire load start
    --deployment "$DEPLOYMENT"
    --test "$TEST_CLASS"
    --args "\"$NLG_ARGS\""
)

# Add --max-tps if specified
if [[ -n "$MAX_TPS" ]]; then
    SOLO_CMD+=(--max-tps "$MAX_TPS")
fi

SOLO_CMD+=(--quiet-mode)

# Add values file if generated
if [[ -n "$VALUES_FILE" && -f "$VALUES_FILE" ]]; then
    echo "  Values file: $VALUES_FILE"
    echo "  --- Values file contents ---"
    cat "$VALUES_FILE"
    echo "  --- End values file ---"
    SOLO_CMD+=(--values-file "$VALUES_FILE")
fi

# Start the load generator
# Note: NLG runs in the background inside the cluster
# Args quoting: Solo requires single quotes outside, double quotes inside
# See: https://github.com/hiero-ledger/solo/blob/main/examples/rapid-fire/Taskfile.yml
echo "  Command: ${SOLO_CMD[*]}"
"${SOLO_CMD[@]}"

echo "load_started=true"
